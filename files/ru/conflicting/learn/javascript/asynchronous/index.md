---
title: "Объединённый асинхронный JavaScript: Таймауты и интервалы"
slug: conflicting/Learn/JavaScript/Asynchronous
original_slug: Learn/JavaScript/Asynchronous/Timeouts_and_intervals
---

{{LearnSidebar}}{{PreviousMenuNext("Learn/JavaScript/Asynchronous/Introducing", "Learn/JavaScript/Asynchronous/Promises", "Learn/JavaScript/Asynchronous")}}

В этом руководстве рассматриваются традиционные методы, доступные в JavaScript для асинхронного выполнения кода по истечении заданного периода времени или через регулярный интервал (например, заданное количество раз в секунду), обсуждаются их полезные свойства и рассматриваются присущие им проблемы. .

<table class="learn-box standard-table">
  <tbody>
    <tr>
      <th scope="row">Необходимые условия:</th>
      <td>
        Базовая компьютерная грамотность, достаточное понимание основ
        JavaScript.
      </td>
    </tr>
    <tr>
      <th scope="row">Цель:</th>
      <td>
        Понимание асинхронных циклов и интервалов, и то как их можно
        использовать.
      </td>
    </tr>
  </tbody>
</table>

## Введение

В течение долгого времени веб-платформа предлагала программистам JavaScript ряд функций, которые позволяли им асинхронно выполнять код по истечении определённого временного интервала и повторно выполнять асинхронный блок кода, пока вы не скажете ему остановиться.

Эти функции:

- [`setTimeout()`](/ru/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout)
  - : Выполняет указанный блок кода один раз по истечении указанного времени
- [`setInterval()`](/ru/docs/Web/API/WindowOrWorkerGlobalScope/setInterval)
  - : Выполняет указанный блок кода несколько раз с определённым интервалом между каждым вызовом.
- [`requestAnimationFrame()`](/ru/docs/Web/API/window/requestAnimationFrame)
  - : Современная версия setInterval (). Выполняют указанный блок кода перед тем, как браузер в следующий раз перерисовывает отображение, позволяя запускать анимацию с подходящей частотой кадров независимо от среды, в которой она выполняется.

Асинхронный код, установленный этими функциями, выполняется в основном потоке (по истечении указанного им таймера).

Важно знать, что вы можете (и часто будете) запускать другой код до выполнения вызова setTimeout () или между итерациями setInterval (). В зависимости от того, насколько интенсивно используются эти операции для процессора, они могут ещё больше задержать выполнение асинхронного кода, поскольку любой асинхронный код будет выполняться только после того, как станет доступен основной поток. (Другими словами, когда стек пуст.) вы узнаете больше по этому вопросу по мере изучения этой статьи.

В любом случае эти функции используются для запуска постоянной анимации и другой фоновой обработки на веб-сайте или в приложении. В следующих разделах мы покажем вам, как их можно использовать.

## setTimeout()

Как мы ранее отметили, setTimeout () выполняет определённый блок кода один раз по истечении заданного времени. Принимает следующие параметры:

- Функция для запуска или ссылка на функцию, определённую в другом месте.
- Число, представляющее интервал времени в миллисекундах (1000 миллисекунд равняется 1 секунде) ожидания перед выполнением кода. Если вы укажете значение 0 (или просто опустите значение), функция запустится как можно скорее. (См. Примечание ниже о том, почему он запускается «как можно скорее», а не «сразу».) Подробнее о том, почему вы, возможно, захотите сделать это позже.
- Значений, представляющие любые параметры, которые вы хотите передать функции при её запуске.

> **Примечание:** Указанное время (или задержка) не является гарантированным временем выполнения, а скорее минимальным временем выполнения. Обратные вызовы, которые вы передаёте этим функциям, не могут выполняться, пока стек в основном потоке не станет пустым.
>
> Как следствие, такой код, как setTimeout (fn, 0), будет выполняться, как только стек будет пуст, а не сразу. Если вы выполните такой код, как setTimeout (fn, 0), но сразу после выполнения цикла, который насчитывает от 1 до 10 миллиардов, ваш колбэк будет выполнен через несколько секунд.

В следующем примере, браузер будет ожидать две секунды перед тем как выполнит анонимную функцию, тогда отобразит сообщение ([живой пример](https://mdn.github.io/learning-area/javascript/asynchronous/loops-and-intervals/simple-settimeout.html), и [исходный код](https://github.com/mdn/learning-area/blob/master/javascript/asynchronous/loops-and-intervals/simple-settimeout.html)):

```js
let myGreeting = setTimeout(function() {
  alert('Hello, Mr. Universe!');
}, 2000)
```

Указанные вами функции не обязательно должны быть анонимными. Вы можете дать своей функции имя и даже определить её где-нибудь ещё и передать ссылку на функцию в setTimeout (). Следующие две версии фрагмента кода эквивалентны первой:

```js
// С именованной функцией
let myGreeting = setTimeout(function sayHi() {
  alert('Hello, Mr. Universe!');
}, 2000)

// С функцией определённой отдельно
function sayHi() {
  alert('Hello Mr. Universe!');
}

let myGreeting = setTimeout(sayHi, 2000);
```

Это может быть полезно, если у вас есть функция, которую нужно вызывать как по таймауту, так например и в ответ на событие. Но это также может помочь поддерживать ваш код в чистоте, особенно если колбэк тайм-аута занимает больше, чем несколько строк кода.

`setTimeout()` возвращает значение идентификатора, которое можно использовать для ссылки на тайм-аут позже, например, когда вы хотите его остановить.

### Передача параметров в функцию setTimeout ()

Любые параметры, которые вы хотите передать функции, выполняемой внутри setTimeout (), должны быть переданы ей как дополнительные параметры в конце списка.

Например, вы можете реорганизовать предыдущую функцию, чтобы она передавала привет любому имени, переданному ей:

```js
function sayHi(who) {
  alert(`Hello ${who}!`);
}
```

Теперь вы можете передать имя в вызов setTimeout () в качестве третьего параметра:

```js
let myGreeting = setTimeout(sayHi, 2000, 'Mr. Universe');
```

### Очистка таймаутов

Наконец, если был создан тайм-аут, вы можете отменить его до истечения указанного времени, вызвав [`clearTimeout()`](/ru/docs/Web/API/WindowOrWorkerGlobalScope/clearTimeout), передав ему идентификатор вызова `setTimeout()` в качестве параметра. Итак, чтобы отменить указанный выше тайм-аут, вы должны сделать следующее:

```js
clearTimeout(myGreeting);
```

> **Примечание:** См.[`greeter-app.html`](https://mdn.github.io/learning-area/javascript/asynchronous/loops-and-intervals/greeter-app.html) для более полной демонстрации, которая позволяет вам указать имя для приветствия и отменить приветствие с помощью отдельной кнопки ([см. исходный код](https://github.com/mdn/learning-area/blob/master/javascript/asynchronous/loops-and-intervals/greeter-app.html)).

## setInterval()

`setTimeout ()` отлично работает, когда вам нужно один раз запустить код по истечении заданного периода времени. Но что происходит, когда вам нужно запускать код снова и снова - например, в случае анимации?

Здесь пригодится [setInterval()](/ru/docs/Web/API/WindowOrWorkerGlobalScope/setInterval) . Работает очень похоже на setTimeout (), за исключением того, что функция, которую вы передаёте в качестве первого параметра, выполняется повторно не менее чем за количество миллисекунд, заданных вторым параметром. Вы также можете передать любые параметры, необходимые для выполняемой функции, в качестве последующих параметров вызова setInterval ().

Давайте посмотрим на пример. Следующая функция создаёт новый объект [`Date()`](/ru/docs/Web/JavaScript/Reference/Global_Objects/Date), с помощью [`toLocaleTimeString()`](/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/toLocaleTimeString) извлекает из него строку с временем и отображает её в пользовательском интерфейсе. Затем он запускает функцию один раз в секунду с помощью `setInterval()`, создавая эффект цифровых часов, которые обновляются раз в секунду ([реальный пример](https://mdn.github.io/learning-area/javascript/asynchronous/loops-and-intervals/setinterval-clock.html), и [исходный код](https://github.com/mdn/learning-area/blob/master/javascript/asynchronous/loops-and-intervals/setinterval-clock.html)):

```js
function displayTime() {
   let date = new Date();
   let time = date.toLocaleTimeString();
   document.getElementById('demo').textContent = time;
}

const createClock = setInterval(displayTime, 1000);
```

Как и `setTimeout ()`, `setInterval ()` возвращает определённое значение, которое вы можете использовать позже, когда вам нужно очистить интервал.

### Очистка интервала

`setInterval()` выполняет задачу постоянно. setInterval () продолжает выполнять задачу вечно, если вы что-то с ней не сделаете. Возможно, вам понадобится способ остановить такие задачи, иначе вы можете получить ошибки, если браузер не сможет выполнить какие-либо другие версии задачи или если анимация, обрабатываемая задачей, завершилась. Вы можете сделать это так же, как останавливаете `timeouts` - передавая идентификатор, возвращаемый вызовом `setInterval()`, в функцию `clearInterval ()`:

```js
const myInterval = setInterval(myFunction, 2000);

clearInterval(myInterval);
```

#### Активное обучение: Создание собственного секундомера!

Учитывая все вышесказанное, у нас есть для вас задача. Возьмите копию нашего примера [`setInterval-clock.html`](https://github.com/mdn/learning-area/blob/master/javascript/asynchronous/loops-and-intervals/setinterval-clock.html) , и измените её так, чтобы создать свой собственный простой секундомер.

Вам нужно отображать время, как и раньше, но в этом примере вам нужно:

- Кнопка "Start" для запуска секундомера.
- Кнопка "Stop" для паузы/остановки.
- Кнопка "Reset", чтобы сбросить счётчик времени на `0`.
- Дисплей времени, чтобы отображать количество прошедших секунд а не фактическое время.

Несколько подсказок для вас:

- Вы можете структурировать и стилизовать разметку кнопок по своему усмотрению; просто убедитесь, что вы используете семантический HTML с кавычками, которые позволяют захватывать ссылки на кнопки с помощью JavaScript.
- Вероятно, вы захотите создать переменную, которая начинается с 0, а затем увеличивается на единицу каждую секунду с использованием постоянного цикла.
- Этот пример проще создать без использования объекта Date (), как мы это делали в нашей версии, но он будет менее точен - вы не можете гарантировать, что колбэк сработает ровно через 1000 мс. Более точным способом было бы запустить startTime = Date.now (), чтобы получить метку времени, когда пользователь нажал кнопку запуска, а затем выполнить Date.now () - startTime, чтобы получить количество миллисекунд после того, как была нажата кнопка запуска .
- Вам также нужно рассчитать количество часов, минут и секунд как отдельные значения, а затем отображать их вместе в строке после каждой итерации цикла. На втором счётчике вы можете отработать каждую из них.
- Как вы могли бы их рассчитать? Подумайте об этом:

  - В одном часе `3600` секунд.
  - Количество минут - это количество секунд, оставшееся после вычитания всех часов, разделённое на 60.
  - Количество секунд будет количеством секунд, оставшихся после вычитания всех минут.

- Вам необходимо включить начальный ноль в отображаемые значения, если сумма меньше `10`, чтобы они больше походили на традиционные часы.
- Чтобы приостановить секундомер, вам нужно очистить интервал. Чтобы сбросить его, вам нудно установить счётчик обратно на `0`, очистить интервал, а затем немедленно обновить отображение.
- Вероятно, вам следует отключить кнопку запуска после её нажатия один раз и снова включить её после того, как вы остановили / сбросили её. В противном случае многократное нажатие кнопки запуска приведёт к применению нескольких `setInterval ()` к часам, что приведёт к неправильному поведению.

> **Примечание:** Если вы застряли, вы можете [увидеть нашу версию](https://mdn.github.io/learning-area/javascript/asynchronous/loops-and-intervals/setinterval-stopwatch.html) (см. также [исходный код](https://github.com/mdn/learning-area/blob/master/javascript/asynchronous/loops-and-intervals/setinterval-stopwatch.html) ).

## Что нужно помнить о `setTimeout()` и `setInterval()`

При работе с `setTimeout()` и `setInterval()` следует помнить о нескольких вещах. Давайте рассмотрим их.

### Рекурсивные таймауты

Есть ещё один способ использования `setTimeout()`: вы можете вызвать его рекурсивно для повторного запуска одного и того же кода вместо использования `setInterval()`.

В приведённом ниже примере используется рекурсивный setTimeout () для запуска переданной функции каждые 100 миллисекунд:

```js
let i = 1;

setTimeout(function run() {
  console.log(i);
  i++;
  setTimeout(run, 100);
}, 100);
```

Сравните приведённый выше пример со следующим - здесь используется `setInterval ()` для достижения того же эффекта:

```js
let i = 1;

setInterval(function run() {
  console.log(i);
  i++
}, 100);
```

#### Чем рекурсивный `setTimeout()` отличается от `setInterval()`?

Разница между двумя версиями приведённого выше кода невелика.

- Рекурсивный `setTimeout ()` гарантирует такую же задержку между выполнениями. (Например, 100 мс в приведённом выше случае.) Код будет запущен, затем подождёт 100 миллисекунд, прежде чем запустится снова, поэтому интервал будет одинаковым, независимо от того, сколько времени требуется для выполнения кода.
- Пример с использованием `setInterval()` работает несколько иначе. Выбранный вами интервал включает время, затрачиваемое на выполнение кода, который вы хотите запустить. Предположим, что выполнение кода занимает `40` миллисекунд - тогда интервал составляет всего `60` миллисекунд.
- При рекурсивном использовании `setTimeout ()` каждая итерация может вычислять различную задержку перед запуском следующей итерации. Другими словами, значение второго параметра может указывать другое время в миллисекундах для ожидания перед повторным запуском кода.

Когда ваш код потенциально может занять больше времени, чем назначенный вами интервал времени, лучше использовать рекурсивный `setTimeout ()` - это сохранит постоянный временной интервал между выполнениями независимо от того, сколько времени потребуется для выполнения кода, и вы избежите ошибок.

### Немедленные таймауты

Использование 0 в качестве значения для `setTimeout ()` позволяет планировать выполнение указанной колбэк-функции как можно скорее, но только после того, как будет запущен основной поток кода.

Например, код приведённый ниже ([рабочий код](https://mdn.github.io/learning-area/javascript/asynchronous/loops-and-intervals/zero-settimeout.html)) выводит alert содержащий `"Hello"`, затем alert содержащий `"World"` как только вы нажмёте ОК в первом alert.

```js
setTimeout(function() {
  alert('World');
}, 0);

alert('Hello');
```

Это может быть полезно в тех случаях, когда вы хотите установить блок кода для запуска, как только весь основной поток завершит работу - поместите его в цикл событий async, чтобы он запускался сразу после этого.

### Очистка с помощью `clearTimeout()` или `clearInterval()`

clearTimeout () и `clearInterval ()` используют один и тот же список записей для очистки. Интересно, что это означает, что вы можете использовать любой метод для очистки setTimeout () или setInterval ().

Для согласованности следует использовать `clearTimeout ()` для очистки записей `setTimeout ()` и `clearInterval ()` для очистки записей `setInterval ()`. Это поможет избежать путаницы.

## requestAnimationFrame()

[`requestAnimationFrame()`](/ru/docs/Web/API/window/requestAnimationFrame) это специализированная функция цикла, созданная для эффективного запуска анимации в браузере. По сути, это современная версия `setInterval ()` - она выполняет указанный блок кода до того, как браузер перерисовывает изображение, позволяя запускать анимацию с подходящей частотой кадров независимо от среды, в которой она выполняется.

Он был создан в ответ на проблемы с `setInterval ()`, который, например, не работает с частотой кадров, оптимизированной для устройства, иногда пропускает кадры, продолжает работать, даже если вкладка не является активной вкладкой или анимация прокручивается со страницы и т. д.([Читай об этом больше в CreativeJS](http://creativejs.com/resources/requestanimationframe/index.html).)

> **Примечание:** вы можете найти примеры использования `requestAnimationFrame()` в этом курсе — например в [Рисование графики](/ru/docs/Learn/JavaScript/Client-side_web_APIs/Drawing_graphics), and [Практика построения объектов](/ru/docs/Learn/JavaScript/Objects/Object_building_practice).

Метод принимает в качестве аргумента колбэк, который должен быть вызван перед перерисовкой. Это общий шаблон, в котором он используется:

```js
function draw() {
   // Drawing code goes here
   requestAnimationFrame(draw);
}

draw();
```

Идея состоит в том, чтобы определить функцию, в которой ваша анимация обновляется (например, ваши спрайты перемещаются, счёт обновляется, данные обновляются или что-то ещё). Затем вы вызываете его, чтобы начать процесс. В конце функционального блока вы вызываете `requestAnimationFrame ()` со ссылкой на функцию, переданной в качестве параметра, и это даёт браузеру указание вызвать функцию снова при следующей перерисовке дисплея. Затем он выполняется непрерывно, поскольку код рекурсивно вызывает `requestAnimationFrame ().`

> **Примечание:** Если вы хотите выполнить простое постоянное анимирование DOM , [CSS Анимация](/ru/docs/Web/CSS/CSS_Animations) вероятно будет быстрее. Она вычисляется непосредственно внутренним кодом браузера, а не JavaScript.
>
> Однако, если вы делаете что-то более сложное, включающее объекты, которые не доступны напрямую в the DOM (такие как [2D Canvas API](/ru/docs/Web/API/Canvas_API) или [WebGL](/ru/docs/Web/API/WebGL_API) ), `requestAnimationFrame()` предпочтительный вариант в большинстве случаев.

### Как быстро работает ваша анимация?

Плавность анимации напрямую зависит от частоты кадров анимации и измеряется в кадрах в секунду (fps). Чем выше это число, тем плавное будет выглядеть ваша анимация до точки.

Поскольку большинство экранов имеют частоту обновления 60 Гц, максимальная частота кадров, к которой вы можете стремиться, составляет 60 кадров в секунду (FPS) при работе с веб-браузерами. Однако большее количество кадров означает больше обработки, которая часто может вызывать заикание и пропуски, также известные как пропадание кадров или заедание.

Если у вас есть монитор с частотой обновления 60 Гц и вы хотите достичь 60 кадров в секунду, у вас есть около 16,7 миллисекунд `(1000/60)` для выполнения кода анимации для рендеринга каждого кадра. Это напоминание о том, что вам нужно помнить об объёме кода, который вы пытаетесь запустить во время каждого прохождения цикла анимации.

`requestAnimationFrame()` всегда пытается приблизиться к этому волшебному значению 60 FPS, насколько это возможно. Иногда это невозможно - если у вас действительно сложная анимация и вы запускаете её на медленном компьютере, частота кадров будет меньше. Во всех случаях `requestAnimationFrame()` всегда будет делать все возможное с тем, что у него есть.

### Чем отличается requestAnimationFrame() от setInterval() and setTimeout()?

Давайте поговорим ещё немного о том, чем метод `requestAnimationFrame ()` отличается от других методов, используемых ранее. Глядя на наш код сверху:

```js
function draw() {
   // Drawing code goes here
   requestAnimationFrame(draw);
}

draw();
```

Такой же код с использованием `setInterval()`:

```js
function draw() {
   // Drawing code goes here
}

setInterval(draw, 17);
```

Как мы уже говорили ранее, вы не указываете временной интервал для `requestAnimationFrame ()`. Просто он работает максимально быстро и плавно в текущих условиях. Браузер также не тратит время на запуск, если по какой-то причине анимация выходит за пределы экрана и т. д.

`setInterval ()`, с другой стороны, требует указания интервала. Мы пришли к нашему окончательному значению 17 по формуле 1000 миллисекунд / 60 Гц, а затем округлили его в большую сторону. Округление - хорошая идея; если вы округлите в меньшую сторону, браузер может попытаться запустить анимацию со скоростью, превышающей 60 кадров в секунду, и в любом случае это не повлияет на плавность анимации. Как мы уже говорили, стандартная частота обновления - 60 Гц.

### В том числе временная метка

Фактическому колбэку, переданному в функцию `requestAnimationFrame ()`, также может быть задан параметр: значение отметки времени, которое представляет время с момента начала работы `requestAnimationFrame ().`

Это полезно, поскольку позволяет запускать вещи в определённое время и в постоянном темпе, независимо от того, насколько быстрым или медленным может быть ваше устройство. Общий шаблон, который вы бы использовали, выглядит примерно так:

```js
let startTime = null;

function draw(timestamp) {
    if (!startTime) {
      startTime = timestamp;
    }

   currentTime = timestamp - startTime;

   // Do something based on current time

   requestAnimationFrame(draw);
}

draw();
```

### Поддержка браузерами

`requestAnimationFrame ()` поддерживается в более поздних версиях браузеров, чем s`etInterval ()` / `setTimeout ()`. Интересно, что он доступен в Internet Explorer 10 и выше.

Итак, если вам не требуется поддержка старых версий IE, нет особых причин не использовать `requestAnimationFrame()`.

### Простой пример

Хватит теории! Давайте выполним упражнение с использованием `requestAnimationFrame()` . Создадим простую анимацию "spinner animation"—вы могли её видеть в приложениях когда происходят задержки при ответе с сервера и т.п..

> **Примечание:** Для такой простой анимации, вам следовало бы использовать CSS . Однако такой вид анимации очень полезен для демонстрации `requestAnimationFrame()` , вы скорее всего будете использовать этот метод когда делаете что-то более сложное, например обновление отображения игры в каждом кадре.

1. Возьмите базовый HTML шаблон ([такой как этот](https://github.com/mdn/learning-area/blob/master/html/introduction-to-html/getting-started/index.html)).
2. Поместите пустой {{htmlelement("div")}} элемент внутри элемента {{htmlelement("body")}}, затем добавьте внутрь символ ↻ . Этот символ будет действовать как spinner в нашем примере.
3. Примените следующий CSS к HTML шаблону (любым предпочитаемым способом). Он установ красный фон на странице, высоту `<body>` равную `100%` высоты {{htmlelement("html")}} , и центрирует `<div>` внутри `<body>`, по горизонтали и вертикали.

    ```css
    html {
      background-color: white;
      height: 100%;
    }

    body {
      height: inherit;
      background-color: red;
      margin: 0;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    div {
      display: inline-block;
      font-size: 10rem;
    }
    ```

4. Разместите {{htmlelement("script")}} элемент перед `</body>` .
5. Разместите следующий JavaScript-код в `<script>` . Здесь вы сохраняете ссылку на `<div>` внутри, устанавливаете для переменной `rotateCount` значение `0`, устанавливаете неинициализированную переменную, которая позже будет использоваться для хранения ссылки на вызов `requestAnimationFrame()`, и устанавливаете для переменной `startTime` значение `null`, которая будет позже использоваться для хранения времени начала `requestAnimationFrame()`.

    ```js
    const spinner = document.querySelector('div');
    let rotateCount = 0;
    let startTime = null;
    let rAF;
    ```

6. Под предыдущим кодом вставьте функцию `draw()` которая будет использоваться для хранения нашего кода анимации, который включает параметр `timestamp` :

    ```js
    function draw(timestamp) {

    }
    ```

7. Внутри `draw ()` добавьте следующие строки. Они определят время начала, если оно ещё не определено (это произойдёт только на первой итерации цикла), и установят для параметра `rotateCount` значение для поворота счётчика (текущая временная метка, возьмите начальную временную метку, разделённую на три, чтобы замедлиться):

    ```js
      if (!startTime) {
       startTime = timestamp;
      }

      rotateCount = (timestamp - startTime) / 3;
    ```

8. Под предыдущей строкой внутри `draw ()` добавьте следующий блок - он проверяет, превышает ли значение `rotateCount 359` (например, `360`, полный круг). Если это так, он устанавливает значение по модулю `360` (то есть остаток, оставшийся после деления значения на `360`), поэтому круговая анимация может продолжаться непрерывно с разумным низким значением. Обратите внимание, что это не является строго необходимым, но легче работать со значениями от 0 до `359` градусов, чем со значениями типа «`128000` градусов».

    ```js
    if (rotateCount > 359) {
      rotateCount %= 360;
    }
    ```

9. Затем, под предыдущим блоком, добавьте следующую строку, чтобы вращать spinner:

    ```js
    spinner.style.transform = `rotate(${rotateCount}deg)`;
    ```

10. В самом низу внутри функции _draw ()_ вставьте следующую строку. Это ключ ко всей операции - вы устанавливаете для переменной, определённой ранее, активный вызов _requestAnimation ()_, который принимает функцию _draw ()_ в качестве своего параметра. Это запускает анимацию, постоянно выполняя функцию _draw ()_ со скоростью, близкой к 60 FPS.

    ```js
    rAF = requestAnimationFrame(draw);
    ```

11. Ниже, вызовите функцию `draw()` для запуска анимации.

    ```js
    draw();
    ```

> **Примечание:** вы можете посмотреть [рабочий образец на GitHub](https://mdn.github.io/learning-area/javascript/asynchronous/loops-and-intervals/simple-raf-spinner.html). ( [исходный код](https://github.com/mdn/learning-area/blob/master/javascript/asynchronous/loops-and-intervals/simple-raf-spinner.html).)

### Очистка вызова requestAnimationFrame()

Очистить вызов `requestAnimationFrame ()` можно, вызвав соответствующий метод `cancelAnimationFrame ()`. (Обратите внимание, что имя функции начинается с «cancel», а не «clear», как у методов «set ...».)

Просто передайте ему значение, возвращаемое вызовом requestAnimationFrame () для отмены, которое вы сохранили в переменной rAF:

```js
cancelAnimationFrame(rAF);
```

### Активное обучение: запуск и остановка нашей анимации

В этом упражнении мы хотели бы, чтобы вы протестировали метод `cancelAnimationFrame ()`, взяв наш предыдущий пример и обновив его, добавив обработчик событий для запуска и остановки счётчика при щелчке мышью в любом месте страницы.

Подсказки:

- Обработчик события щелчка можно добавить к большинству элементов, включая документ `<body>`. Имеет смысл поместить его в элемент `<body>`, если вы хотите максимизировать интерактивную область - событие всплывает до его дочерних элементов.
- Вы захотите добавить переменную отслеживания, чтобы проверить, вращается ли счётчик или нет, очистив кадр анимации, если он есть, и снова вызвать его, если это не так.

> **Примечание:** Для начала попробуйте сами; если вы действительно застряли, посмотрите наш [живой пример](https://mdn.github.io/learning-area/javascript/asynchronous/loops-and-intervals/start-and-stop-spinner.html) и [исходный код](https://github.com/mdn/learning-area/blob/master/javascript/asynchronous/loops-and-intervals/start-and-stop-spinner.html).

### Регулировка анимации `requestAnimationFrame()`

Одним из ограничений `requestAnimationFrame ()` является то, что вы не можете выбирать частоту кадров. В большинстве случаев это не проблема, так как обычно вы хотите, чтобы ваша анимация работала как можно плавное. Но как насчёт того, чтобы создать олдскульную 8-битную анимацию?

Это было проблемой, например в анимации ходьбы, вдохновлённой островом обезьян, из статьи [Drawing Graphics](/ru/docs/Learn/JavaScript/Client-side_web_APIs/Drawing_graphics):

{{EmbedGHLiveSample("learning-area/javascript/apis/drawing-graphics/loops_animation/7_canvas_walking_animation.html", '100%', 260)}}

В этом примере вы должны анимировать как положение персонажа на экране, так и отображаемый спрайт. В анимации спрайта всего 6 кадров. Если бы вы показывали разные кадры спрайта для каждого кадра, отображаемого на экране, с помощью requestAnimationFrame (), Guybrush двигал бы конечностями слишком быстро, и анимация выглядела бы нелепо. Следовательно, в этом примере регулируется скорость, с которой спрайт циклически повторяет свои кадры, используя следующий код:

```js
if (posX % 13 === 0) {
  if (sprite === 5) {
    sprite = 0;
  } else {
    sprite++;
  }
}
```

Таким образом, код циклически повторяет спрайт только один раз каждые 13 кадров анимации.

... Фактически, это примерно каждые 6,5 кадров, поскольку мы обновляем posX (положение персонажа на экране) на два кадра:

```js
if (posX > width/2) {
  newStartPos = -( (width/2) + 102 );
  posX = Math.ceil(newStartPos / 13) * 13;
  console.log(posX);
} else {
  posX += 2;
}
```

Это код, который вычисляет, как обновлять позицию в каждом кадре анимации.

Метод, который вы используете для регулирования анимации, будет зависеть от вашего конкретного кода. Например, в предыдущем примере счётчика вы могли заставить его двигаться медленнее, увеличивая rotateCount только на единицу в каждом кадре вместо двух.

## Активное обучение: игра на реакцию

В последнем разделе этой статьи вы создадите игру на реакцию для двух игроков. В игре будет два игрока, один из которых управляет игрой с помощью клавиши <kbd>A</kbd>, а другой - с помощью клавиши<kbd> L</kbd>.

При нажатии кнопки «Start» счётчик, подобный тому, что мы видели ранее, отображается в течение случайного промежутка времени от 5 до 10 секунд. По истечении этого времени появится сообщение «PLAYERS GO !!» - как только это произойдёт, первый игрок, который нажмёт свою кнопку управления, выиграет игру.

{{EmbedGHLiveSample("learning-area/javascript/asynchronous/loops-and-intervals/reaction-game.html", '100%', 500)}}

Давайте поработаем над этим:

1. Прежде всего, скачайте [стартовый файл](https://github.com/mdn/learning-area/blob/master/javascript/asynchronous/loops-and-intervals/reaction-game-starter.html). Он содержит законченную структуру HTML и стили CSS, что даёт нам игровую доску, которая показывает информацию двух игроков (как показано выше), но с счётчиком и параграфом результатов, отображаемыми друг над другом. Вам нужно просто написать JavaScript-код.
2. Внутри пустого элемента {{htmlelement("script")}} на вашей странице, начните с добавления следующих строк кода, которые определяют некоторые переменные и константы, которые вам понадобятся в дальнейшем:

    ```js
    const spinner = document.querySelector('.spinner p');
    const spinnerContainer = document.querySelector('.spinner');
    let rotateCount = 0;
    let startTime = null;
    let rAF;
    const btn = document.querySelector('button');
    const result = document.querySelector('.result');
    ```

    В следующем порядке:

    1. Ссылка на спиннер, чтобы вы могли его анимировать.
    2. Ссылка на элемент {{htmlelement("div")}} содержащий спиннер, используемый для отображения и скрытия.
    3. Счётчик поворотов. Он определяет, на сколько вы хотите показывать вращение спиннера на каждом кадре анимации.
    4. Нулевое время начала. Это будет заполнено временем начала, когда счётчик начнёт вращаться.
    5. Неинициализированная переменная для последующего хранения вызова {{domxref("Window.requestAnimationFrame", "requestAnimationFrame()")}} который анимирует спиннер.
    6. Ссылка на кнопку Start .
    7. Ссылка на параграф результатов.

3. Ниже добавьте следующую функцию. Она просто берёт два числа и возвращает случайное число между ними. Это понадобится вам позже, чтобы сгенерировать случайный интервал ожидания.

    ```js
    function random(min,max) {
      var num = Math.floor(Math.random()*(max-min)) + min;
      return num;
    }
    ```

4. Затем добавьте функцию draw(), которая анимирует спиннер. Это очень похоже на версию из предыдущего примера простого счётчика:

    ```js
    function draw(timestamp) {
      if(!startTime) {
       startTime = timestamp;
      }

      rotateCount = (timestamp - startTime) / 3;

      if(rotateCount > 359) {
        rotateCount %= 360;
      }

      spinner.style.transform = 'rotate(' + rotateCount + 'deg)';
      rAF = requestAnimationFrame(draw);
    }
    ```

5. Теперь пришло время настроить начальное состояние приложения при первой загрузке страницы. Добавьте следующие две строки, которые просто скрывают абзац результатов и контейнер счётчика с помощью `display: none` ;.

    ```js
    result.style.display = 'none';
    spinnerContainer.style.display = 'none';
    ```

6. Затем определите функцию `reset()`, которая возвращает приложение в исходное состояние, необходимое для повторного запуска игры после её завершения. Добавьте в конец кода следующее:

    ```js
    function reset() {
      btn.style.display = 'block';
      result.textContent = '';
      result.style.display = 'none';
    }
    ```

7. Хорошо, хватит подготовки! Пришло время сделать игру доступной! Добавьте в свой код следующий блок. Функция `start ()` вызывает `draw ()`, чтобы запустить вращение спиннера и отобразить его в пользовательском интерфейсе, скрыть кнопку Start, чтобы вы не могли испортить игру, запустив её несколько раз одновременно, и запускает вызов `setTimeout ()`, который выполняется функция `setEndgame ()` по прошествии случайного интервала от 5 до 10 секунд. Следующий блок также добавляет обработчик событий к вашей кнопке для запуска функции `start ()` при её нажатии.

    ```js
    btn.addEventListener('click', start);

    function start() {
      draw();
      spinnerContainer.style.display = 'block';
      btn.style.display = 'none';
      setTimeout(setEndgame, random(5000,10000));
    }
    ```

    > **Примечание:** вы увидите, что этот пример вызывает `setTimeout()` без сохранения возвращаемого значения. (не `let myTimeout = setTimeout(functionName, interval)`.)
    >
    > Это прекрасно работает, если вам не нужно очищать интервал / тайм-аут в любой момент. Если вы это сделаете, вам нужно будет сохранить возвращённый идентификатор!

    Конечным результатом предыдущего кода является то, что при нажатии кнопки «Start» отображается спиннер, и игроки вынуждены ждать произвольное количество времени, прежде чем их попросят нажать их кнопку. Эта последняя часть обрабатывается функцией `setEndgame ()`, которую вы определите позже.

8. Добавьте в свой код следующую функцию:

    ```js
    function setEndgame() {
      cancelAnimationFrame(rAF);
      spinnerContainer.style.display = 'none';
      result.style.display = 'block';
      result.textContent = 'PLAYERS GO!!';

      document.addEventListener('keydown', keyHandler);

      function keyHandler(e) {
        let isOver = false;
        console.log(e.key);

        if (e.key === "a") {
          result.textContent = 'Player 1 won!!';
          isOver = true;
        } else if (e.key === "l") {
          result.textContent = 'Player 2 won!!';
          isOver = true;
        }

        if (isOver) {
          document.removeEventListener('keydown', keyHandler);
          setTimeout(reset, 5000);
        }
      };
    }
    ```

    Выполните следующие инструкции:

    1. Во-первых, отмените анимацию спиннера с помощью {{domxref("window.cancelAnimationFrame", "cancelAnimationFrame()")}} (всегда полезно очистить ненужные процессы), и скройте контейнер счётчика.
    2. Затем, отобразите абзац с результатами и установите для его текстового содержимого значение "PLAYERS GO!!" чтобы сообщить игрокам, что теперь они могут нажать свою кнопку, чтобы победить.
    3. Прикрепите к документу обработчик событий [`keydown`](/ru/docs/Web/API/Document/keydown_event) . При нажатии любой кнопки запускается функция `keyHandler()`.
    4. Внутри `keyHandler()`, код включает объект события в качестве параметра (представленного `e`) — его свойство {{domxref("KeyboardEvent.key", "key")}} содержит только что нажатую клавишу, и вы можете использовать это для ответа на определённые нажатия клавиш определёнными действиями.
    5. Установите для переменной `isOver` значение false, чтобы мы могли отслеживать, были ли нажаты правильные клавиши, чтобы игрок 1 или 2 выиграл. Мы не хотим, чтобы игра заканчивалась при нажатии неправильной клавиши.
    6. Регистрация `e.key` в консоли, это полезный способ узнать значение различных клавиш, которые вы нажимаете.
    7. Когда `e.key` принимает значение "a", отобразить сообщение о том, что Player 1 выиграл, а когда `e.key` это "l", отобразить сообщение о том, что Player 2 выиграл. (**Note:** Это будет работать только со строчными буквами a и l — если переданы прописные A или L , это считается другими клавишами!) Если была нажата одна из этих клавиш, установите для `isOver` значение `true`.
    8. Только если `isOver` равно `true`, удалите обработчик событий `keydown` с помощью {{domxref("EventTarget.removeEventListener", "removeEventListener()")}} чтобы после того, как произошло выигрышное нажатие, больше не было возможности ввода с клавиатуры, чтобы испортить финальный результат игры. Вы также используете `setTimeout()` для вызова `reset()` через 5 секунд — как объяснялось ранее, эта функция сбрасывает игру обратно в исходное состояние, чтобы можно было начать новую игру.

Вот и все - вы справились!

> **Примечание:** Если вы где то застряли, взгляните на [наша версия игры](https://mdn.github.io/learning-area/javascript/asynchronous/loops-and-intervals/reaction-game.html) (см. также [исходный код](https://github.com/mdn/learning-area/blob/master/javascript/asynchronous/loops-and-intervals/reaction-game.html) ).

## Заключение

Вот и все — все основы асинхронных циклов и интервалов рассмотрены в статье. Вы найдёте эти методы полезными во многих ситуациях, но постарайтесь не злоупотреблять ими! Поскольку они по-прежнему выполняются в основном потоке, тяжёлые и интенсивные колбэки (особенно те, которые управляют DOM) могут действительно замедлить страницу, если вы не будете осторожны.

{{PreviousMenuNext("Learn/JavaScript/Asynchronous/Introducing", "Learn/JavaScript/Asynchronous/Promises", "Learn/JavaScript/Asynchronous")}}
